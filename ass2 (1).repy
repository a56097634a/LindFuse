###########################################################################
##
## Modified by: Tianming Xu
## NYU ID:    N19118477
##
## CSEFSCK - File System ChecKer
## This Program is designed to parse the lind.metadata, the file inode-table
## generated by lind-fuse in the HW3 and the free blocks status. 
## This program checks file system's validitation.
##
###########################################################################

#
#This function is extracted from Lind-Fuse by Prof. Cappos (serialize.repy)
#original: deserializedata(datastr)
#

def parsedata(datastr):
  if type(datastr) != str:
    raise TypeError("Cannot parse data")
  typeindicator = datastr[0]
  restofstring = datastr[1:]

  # None
  if typeindicator == 'N':
    if restofstring != '':
      raise ValueError("None")
    return None

  # Boolean
  elif typeindicator == 'B':
    if restofstring == 'T':
      return True
    elif restofstring == 'F':
      return False
    raise ValueError("Boolean")

  # Integer
  elif typeindicator == 'I':
    try:
      return int(restofstring) 
    except ValueError:
      raise ValueError("Integer")

  # Float
  elif typeindicator == 'F':
    try:
      return float(restofstring) 
    except ValueError:
      raise ValueError("Float")

  # String
  elif typeindicator == 'S':
    return restofstring

  # List, Tuple, set, frozenset
  elif typeindicator == 'L' or typeindicator == 'T' \
       or typeindicator == 's' or typeindicator == 'f':
    list = []

    data = restofstring
    # With 0: as end of the set
    while data != '0:':
      l, rest = data.split(':', 1)
      length = int(l)
      list.append(parsedata(rest[:length]))
      data = rest[length:]

    if typeindicator == 'L':
      return list
    elif typeindicator == 'T':
      return tuple(list)
    elif typeindicator == 's':
      return set(list)
    elif typeindicator == 'f':
      return frozenset(list)
    else:
      raise Exception("List, Tuple, set, frozenset")

  # Dictionary
  elif typeindicator == 'D':
    l, rest = restofstring.split(':', 1)
    length = int(l)
    keys = parsedata(rest[:length])
    values = parsedata(rest[length:])

    if type(keys) != type([]) or type(values) != type([]) \
       or len(keys) != len(values):
      raise ValueError("Dictionary")
    
    dict = {}
    for i in xrange(len(keys)):
      dict[keys[i]] = values[i]
    return dict

  # Otherwise
  else:
    raise ValueError("Unknown type")

#######################
##                   ##
##      CSEFSCK      ##
##                   ##
#######################

superblock = {}
entries = {}
dirs = {}
files = {}
fid = 'filename_to_inode_dict'
blocksize = 4096

#   DEBUG
#   Prints result of each validation step
#

def print_result(title, error):
    print title, ':',
    if error == 1:
        print 'Wrong'
    elif error == 0:
        print 'Right'
    else:
        print 'Can't check that'

#
#   Loads parsed data in global variables
#   load the data before check file system
#

def loaddata(data, tab=0):
    for item in data:
        superblock[item] = data[item]
    for item in superblock['inodetable']:
        entries[item] = superblock['inodetable'][item]
    for item in entries:
        if fid in entries[item]:
            dirs[item] = entries[item]
        else:
            files[item] = entries[item]

#
#   Check the validation of device id
#

def check_dev_id():
    print 'Verify device id ...'
    print_result('Device id', superblock['dev_id'] != 20)

#
#   Checks the validity of dates of the files
#

def check_dates():
    print 'Verify dates ...'
    ftime = 2000000000 
    error = 0
    
    for item in entries:
        if not ( entries[item]['atime'] < ftime and \
                 entries[item]['mtime'] < ftime and \
                 entries[item]['ctime'] < ftime):
            print 'Failed at block ', item
            error = 1        

    print_result('Dates', error)

#
#   Checks the validity of free blocks in the file system
#

def check_free_blocks():
    print 'Check free blocks in system ...'
    error = 0

    print '- Map free block lists'
    for f in files:        
        try:
            lindfile = open('linddata.' + str(f), 'r')
            lindfile.close()
        except:
            print 'Failed to locate mapped block', f
            error = 1

    print '- Map files to blocks'
    
    for f in listdir():
        if 'linddata' in str(f):
            block = f.split('.')[1]
            if not int(block) in files:
                print 'File mapped to free block', block
                error = 1

    print_result('Check free blocks', error)

#
#   Checks the validity of directory mapping
#

def check_dirs():
    print 'Check directory mapping ...'
    errocc = 0

    # Check . mapping
    print '- Checking self(.) mapping'
    for d in dirs:
        if dirs[d][fid]['.'] != d:
            print 'Failed to map . at block: ', item
            errocc = 1

    # Check .. mapping
    print '- Checking parent(..) mapping'    
    for d in dirs:        
        for entry in dirs[d][fid]:
            if entry != '.' and entry != '..':
                child = dirs[d][fid][entry]
                if child in dirs:
                    if d != dirs[child][fid]['..']:
                        print 'Failed to map .. from block', child, 'to', d
                        errocc = 1

    print_result('Directory mapping', errocc)

#
#   Checks the validity of number of links in the directory
#
def count_dir_links():
    print 'Counting directory links ...'
    errocc = 0

    for d in dirs:
        if dirs[d]['linkcount'] != len(dirs[d][fid]):
            print 'Link count mismatch at block', d
            errocc = 1

    print_result('Directory link count', errocc)

#
#   Checks the validity of indirect links
#   Prints 'Not Suported' if the file system does not support
#   indirect file mapping
#
def check_indirect_links():
    print 'Checking indirect links ...'
    errocc = 0

    # Get first file entry
    i = files.iterkeys().next()
    
    # Check if indirect mapping is supported in file system
    if 'indirect' in files[i] and 'location' in files[i]:
        for f in files:
            if not (files[f]['indirect'] !=0 and \
                    type(files[f]['location']) == type([])):
                print 'Invalid indirect mapping at block', f
                errocc = 1
    # Does not support indirect mapping
    else:
        print '- Indirect mapping is not supported'
        errocc = -1        

    print_result('Indirect links', errocc)

#
#   Checks the validity of block sizes
#   Prints 'Not Suported' if the file system does not support
#   indirect file mapping and dividing files in to blocks
#
def check_block_size():
    print 'Checking block sizes ...'
    errocc = 0

    # Get first file entry
    i = files.iterkeys().next()
    
    # Check if indirect mapping is supported in file system
    if 'indirect' in files[i] and 'location' in files[i]:
        for f in files:
            size = files[f]['size']
            indir = files[f]['indirect']
            l = len(files[f]['location'])
            if not (size >= 0 and size < blocksize and indir == 0) or \
               not (size > blocksize and size < l * blocksize and \
                    size > (l - 1) * blocksize and indir != 0):
                print 'Invalid block size at block', f
                errocc = 1
                
    # Does not support indirect mapping, so no multi-file-blocks
    else:
        print '- Indirect mapping is not supported'
        print '- Dividing files in to blocks is not supported'
        errocc = -1

    print_result('Distributing file blocks', errocc)

#
#   The main function
#
def main(args):
    # Check for valid command line arguments
    if len(args) < 1:
        print 'ERROR: Invalid arguments, expected atleat one'
        print 'USAGE 1: python repy.py restrictions.test ass2.repy',\
              '<super block file>'
        print 'USAGE 2 (seash): run ass2.repy <super block file>'        
        return 1
    
    metafile = None
    # Try to open the superblock
    try:
        metafile = open(args[0])
    except:
        print 'ERROR: Cannot open file', args[0]
        return 1
    
    metadata = metafile.read()

    # Try to parse superblock
    try:
        print 'Loading Superblock ...',
        data = parsedata(metadata)
        loaddata(data)
        print 'Success'
    except:
        print 'Failed'
        return 1

    # Start validating the file system
    print '\nCSEFSCK Started\n'
    
    check_dev_id()
    check_dates()
    check_free_blocks()
    check_dirs()
    count_dir_links()
    check_indirect_links()
    check_block_size()
    
    print '\nFinished CSEFSCK'
    # Close the superblock file
    metafile.close()

    return 0
    
if callfunc == "initialize":
    main(callargs)
